#include <iostream>
#include <vector>
#include <algorithm>

typedef uint8_t byte;
typedef uint32_t word;
typedef std::vector<std::vector<byte>> byte_vector2d;

#define TOP_NIBBLE(b)     (((b)>>4) & 0xF)
#define BOTTOM_NIBBLE(b)  ((b) & 0xF)

byte Sbox[16][16] = {
    {0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76},
    {0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0},
    {0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15},
    {0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75},
    {0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84},
    {0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf},
    {0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8},
    {0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2},
    {0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73},
    {0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb},
    {0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79},
    {0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08},
    {0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a},
    {0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e},
    {0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf},
    {0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16}
};

byte InvSbox[16][16] = {
    { 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb } ,
    { 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb } ,
    { 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e } ,
    { 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25 } ,
    { 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92 } ,
    { 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84 } ,
    { 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06 } ,
    { 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b } ,
    { 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73 } ,
    { 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e } ,
    { 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b } ,
    { 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4 } ,
    { 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f } ,
    { 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef } ,
    { 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61 } ,
    { 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d }
};

word Rcon[] = { 0x00000000, // Rcon[] is 1-based, so the first entry is just a place holder
    0x01000000, 0x02000000, 0x04000000, 0x08000000,
    0x10000000, 0x20000000, 0x40000000, 0x80000000,
    0x1B000000, 0x36000000, 0x6C000000, 0xD8000000,
    0xAB000000, 0x4D000000, 0x9A000000, 0x2F000000,
    0x5E000000, 0xBC000000, 0x63000000, 0xC6000000,
    0x97000000, 0x35000000, 0x6A000000, 0xD4000000,
    0xB3000000, 0x7D000000, 0xFA000000, 0xEF000000,
    0xC5000000, 0x91000000, 0x39000000, 0x72000000,
    0xE4000000, 0xD3000000, 0xBD000000, 0x61000000,
    0xC2000000, 0x9F000000, 0x25000000, 0x4A000000,
    0x94000000, 0x33000000, 0x66000000, 0xCC000000,
    0x83000000, 0x1D000000, 0x3A000000, 0x74000000,
    0xE8000000, 0xCB000000, 0x8D000000
};

void printBlock(byte_vector2d block) {
    for (unsigned col = 0; col < 4; col++) {
        for (unsigned row = 0; row < 4; row++) {
            printf("%02x", block[row][col]);
        }
    }
}

void printWordArray(word w[], unsigned size) {
    for (unsigned i = 0; i < size; i++) {
        printf("%08x", w[i]);
    }
}

void printDebugLine(unsigned round, std::string type, byte_vector2d block) {
    std::cout << "round[" << round << "]." << type << "   ";
    printBlock(block);
    std::cout << std::endl;
}

void printDebugLine(unsigned round, std::string type, word w[]) {
    std::cout << "round[" << round << "]." << type << "   ";
    printWordArray(w, 4);
    std::cout << std::endl;
}

byte ffadd(byte a, byte b) {
    return a^b;
}

byte xtime(byte b) {
    if (b & (1 << 7)) {
        b <<= 1;
        b ^= 0x1b;
    } else {
        b <<= 1;
    }
    return b;
}

byte ffmultiply(byte a, byte b) {
    byte answer = 0;
    byte runningValue = a;
    for (unsigned i = 0; i < 8; i++) {
        if (b & (1<<i)) {
            answer = ffadd(answer, runningValue);
        }
        runningValue = xtime(runningValue);
    }
    return answer;
}

word subWord(word w) {
    for (unsigned i = 0; i < 4; i++) {
        unsigned shift = i*8;
        byte oldByte = (byte)(w >> shift);
        byte newByte = Sbox[TOP_NIBBLE(oldByte)][BOTTOM_NIBBLE(oldByte)];
        w ^= oldByte << shift;
        w |= newByte << shift;
    }
    return w;
}

word rotWord(word w) {
    return (w << 8) | ((w >> 24) & 0xFF);
}

void addRoundKeys(byte_vector2d& block, word w[]) {
    for (unsigned col = 0; col < 4; col++) {
        for (unsigned row = 0; row < 4; row++) {
            block[row][col] ^= w[col] >> ((3-row)*8);
        }

    }
}

void subBytes(byte_vector2d& block) {
    for (auto row = block.begin(); row != block.end(); row++) {
        for (auto col = row->begin(); col != row->end(); col++) {
            byte oldByte = *col;
            *col = Sbox[TOP_NIBBLE(oldByte)][BOTTOM_NIBBLE(oldByte)];
        }
    }
}

void shiftRows(byte_vector2d& block) {
    unsigned i = 1;
    for (auto row = block.begin()+i; row != block.end(); row++, i++) {
        std::rotate(row->begin(), row->begin()+i, row->end());
    }
}

void mixColumns(byte_vector2d& block) {
    unsigned long numCols = block.front().size();
    for (unsigned col = 0; col < numCols; col++) {
        byte block0 = block[0][col];
        byte block1 = block[1][col];
        byte block2 = block[2][col];
        byte block3 = block[3][col];
        block[0][col] = ffmultiply(0x02, block0) ^ ffmultiply(0x03, block1) ^ block2 ^ block3;
        block[1][col] = block0 ^ ffmultiply(0x02, block1) ^ ffmultiply(0x03, block2) ^ block3;
        block[2][col] = block0 ^ block1 ^ ffmultiply(0x02, block2) ^ ffmultiply(0x03, block3);
        block[3][col] = ffmultiply(0x03, block0) ^ block1 ^ block2 ^ ffmultiply(0x02, block3);
    }
}

word packWord(byte b1, byte b2, byte b3, byte b4) {
    return ((word)b1 << 24) | ((word)b2 << 16) | ((word)b3 << 8) | (word)b4;
}

void keyExpansion(unsigned Nk, unsigned Nr, byte key[], word w[]) {
    word temp;
    unsigned i;
    for (i = 0; i < Nk; i++) {
        w[i] = packWord(key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]);
    }
    for (; i < 4*(Nr+1); i++) {
        temp = w[i-1];
        if (i % Nk == 0) {
            temp = subWord(rotWord(temp)) ^ Rcon[i/Nk];
        } else if (Nk > 6 and i % Nk == 4) {
            temp = subWord(temp);
        }
        w[i] = w[i-Nk] ^ temp;
    }
}

/*
 * Transforms the plain-text from parameter block into cipher-text
 *
 */
void cipher(unsigned Nr, byte_vector2d& block, word w[]) {
    printDebugLine(0, "input", block);
    addRoundKeys(block, &w[0]);
    printDebugLine(0, "k_sch", &w[0]);

    for (unsigned round = 1; round < Nr; round++) {
        printDebugLine(round, "start", block);
        subBytes(block);
        printDebugLine(round, "s_box", block);
        shiftRows(block);
        printDebugLine(round, "s_row", block);
        mixColumns(block);
        printDebugLine(round, "m_col", block);
        addRoundKeys(block, &w[round*4]);
        printDebugLine(round, "k_sch", &w[round*4]);
    }

    printDebugLine(Nr, "start", block);
    subBytes(block);
    printDebugLine(Nr, "s_box", block);
    shiftRows(block);
    printDebugLine(Nr, "s_row", block);
    addRoundKeys(block, &w[Nr*4]);
    printDebugLine(Nr, "k_sch", &w[Nr*4]);
    printDebugLine(Nr, "o_put", block);
}

int main() {
    byte key128_a[] = {
            0x2b, 0x7e, 0x15, 0x16,
            0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88,
            0x09, 0xcf, 0x4f, 0x3c,
    };

    byte key192_a[] = {
            0x8e, 0x73, 0xb0, 0xf7,
            0xda, 0x0e, 0x64, 0x52,
            0xc8, 0x10, 0xf3, 0x2b,
            0x80, 0x90, 0x79, 0xe5,
            0x62, 0xf8, 0xea, 0xd2,
            0x52, 0x2c, 0x6b, 0x7b,
    };

    byte key256_a[] = {
            0x60, 0x3d, 0xeb, 0x10,
            0x15, 0xca, 0x71, 0xbe,
            0x2b, 0x73, 0xae, 0xf0,
            0x85, 0x7d, 0x77, 0x81,
            0x1f, 0x35, 0x2c, 0x07,
            0x3b, 0x61, 0x08, 0xd7,
            0x2d, 0x98, 0x10, 0xa3,
            0x09, 0x14, 0xdf, 0xf4,
    };

    byte_vector2d block_b = {
            {0x32, 0x88, 0x31, 0xe0},
            {0x43, 0x5a, 0x31, 0x37},
            {0xf6, 0x30, 0x98, 0x07},
            {0xa8, 0x8d, 0xa2, 0x34}
    };

    byte_vector2d block_c = {
            {0x00, 0x44, 0x88, 0xcc},
            {0x11, 0x55, 0x99, 0xdd},
            {0x22, 0x66, 0xaa, 0xee},
            {0x33, 0x77, 0xbb, 0xff},
    };

    byte key128_c[] = {
            0x00, 0x01, 0x02, 0x03,
            0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0a, 0x0b,
            0x0c, 0x0d, 0x0e, 0x0f,
    };

    byte key192_c[] = {
            0x00, 0x01, 0x02, 0x03,
            0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0a, 0x0b,
            0x0c, 0x0d, 0x0e, 0x0f,
            0x10, 0x11, 0x12, 0x13,
            0x14, 0x15, 0x16, 0x17,
    };

    byte key256_c[] = {
            0x00, 0x01, 0x02, 0x03,
            0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0a, 0x0b,
            0x0c, 0x0d, 0x0e, 0x0f,
            0x10, 0x11, 0x12, 0x13,
            0x14, 0x15, 0x16, 0x17,
            0x18, 0x19, 0x1a, 0x1b,
            0x1c, 0x1d, 0x1e, 0x1f,
    };

    unsigned Nk = 8;
    unsigned Nr = Nk + 6;

    word w[4*(Nr+1)];
    keyExpansion(Nk, Nr, key256_c, w);

    cipher(Nr, block_c, w);

    return 0;
}
